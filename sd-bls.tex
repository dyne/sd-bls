\documentclass[conference]{IEEEtran}
% \IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
%% \usepackage{natbib}

\usepackage{listings}
\lstdefinestyle{lua}{
  language=[5.3]Lua,
  basicstyle=\ttfamily,
  keywordstyle=\color{magenta},
  stringstyle=\color{blue},
  commentstyle=\color{black!50}
}
% solarized
\lstset{
    % How/what to match
    sensitive=false,
    % Extra margin on line (align with paragraph)
    xleftmargin=\parindent,
    % Put extra space under caption
    belowcaptionskip=1\baselineskip,
    % Break long lines into multiple lines?
    breaklines=true,
    % Show a character for spaces?
    showstringspaces=false,
    tabsize=2
}

\definecolor{eclipseStrings}{RGB}{42,0.0,255}
\definecolor{eclipseKeywords}{RGB}{127,0,85}
\colorlet{numb}{magenta!60!black}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    commentstyle=\color{eclipseStrings}, % style of comment
    stringstyle=\color{eclipseKeywords}, % style of strings
%    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
%    breaklines=true,
%    frame=lines,
    string=[s]{"}{"},
    comment=[l]{:\ "},
    morecomment=[l]{:"},
    literate=
        *{0}{{{\color{numb}0}}}{1}
         {1}{{{\color{numb}1}}}{1}
         {2}{{{\color{numb}2}}}{1}
         {3}{{{\color{numb}3}}}{1}
         {4}{{{\color{numb}4}}}{1}
         {5}{{{\color{numb}5}}}{1}
         {6}{{{\color{numb}6}}}{1}
         {7}{{{\color{numb}7}}}{1}
         {8}{{{\color{numb}8}}}{1}
         {9}{{{\color{numb}9}}}{1}
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Privacy Preserving Selective Disclosure and Issuer Revocation of Verifiable Credentials\\
%% {\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and should not be used}
\thanks{Dyne.org Foundation}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Denis Roio}
\IEEEauthorblockA{
% \textit{dept. name of organization (of Aff.)} \\
\textit{Dyne.org Foundation}\\
Amsterdam, The Netherlands \\
jaromil@dyne.org}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Andrea D'Intino}
\IEEEauthorblockA{
% \textit{dept. name of organization (of Aff.)} \\
\textit{The Forkbomb Company}\\
Copenhagen, Denmark \\
andrea@forkbomb.eu}
}

\maketitle

\begin{abstract}

It is of critical importance to design digital identity systems that
ensure the privacy of citizens as well protect them from issuer
corruption. Unfortunately, what Europe and USA public sector is
currently developing does not offer such basic protections. As a
solution we introduce a method for untraceable selective disclosure
and privacy preserving revocation of digital credentials, utilizing
the unique homomorphic characteristics of second order Elliptic Curves
and Boneh-Lynn-Shacham (BLS) signatures operated on them. Our approach
ensures that users can selectively reveal only the necessary
attributes, while protecting their privacy across multiple
presentations and against colluding verifiers. Since we also want to
protect users from issuer corruption, we apply a threshold for
credential issuance and revocation to mandate a collective agreement
among multiple issuers. Finally, our method of revocation does not
give out any information on the identity of holders of revoked
credentials.

\end{abstract}

\begin{IEEEkeywords}
Privacy, Selective disclosure, BLS signatures, Digital credentials
\end{IEEEkeywords}

\section{Introduction}
Digital identity systems implement credential issuance and presentation mechanisms so that a person can voluntarily disclose his or her own acquired skills, professed attributes, or completed accomplishments. Credentials are signed by issuer authorities and encapsulated within various forms of digital proofs to be held in digital wallets, empowering individuals to reveal only chosen details to designated recipients, to limit data exposure and permit a user-controlled release of information.

Such systems are known as selective disclosure and this article aims at improving their cryptographic implementation to adhere to basic privacy-by-design standards.

\subsection{State of the art}

Selective disclosures are being used by nation states across the world in their next generation identity systems, for instance EIDAS2.0 in Europe where the European Digital Identity Wallet Architecture and Reference Framework\cite{eudi-arf} mandates the use of SD-JWT\cite{sd-jwt}. Unfortunately SD-JWT adopts simple HMAC based cryptography to generate proofs that can be traced.

In North America the situation seems to be slightly different: the cryptography adopted is based on the BBS+ algorithm\cite{bbs+} leveraging its Zero Knowledge Proof properties and applied to W3C Verifiable Credentials\cite{w3c-vc} to obtain an higher degree of privacy.

The different choice of syntax in these two approaches is negligible, being Javascript Web Tokens or W3C Verifiable Credentials doesn't changes much from our point of view. But the cryptographic algorithms adopted have great importance for our purpose and they lack the features necessary to face three important threats which render them unsuitable to be used in real world situations.

\subsection{Threats considered}

\paragraph{Linkability}

Every presentation of an HMAC proof in SD-JWT is identical and this makes it possible for colluding verifiers to trace an holder identity by following disclosures. In order to preserve the privacy of a credential holder the proofs disclosed by the wallet should not be traceable across different presentations. This threat appears to be well mitigated by BBS+ through its Zero Knowledge Proof implementation.

\paragraph{Lack of Revocation}

There is no revocation system designed, either for HMAC or BBS+. This may be mitigated by expiration dates, but in most cases expiration is not enough and interactive revocation is necessary. If the choice of strategy is left open to developers, we will face huge privacy breaches with the adoption of public revocation lists.

%% - https://github.com/ministero-salute/it-dgc-verificaC19-android/issues/103
%% - https://osf.io/preprints/lawarxiv/yc6xu


\paragraph{Issuer Corruption}

If the choice of interactive revocation is left to a single issuer, one may unilaterally choose to revoke credentials, without being subject to revision or having to seek consensus with a quorum of issuers. This situation leads to censorship and persecution of engaged individuals like journalists or activists living under dictatorial regimes that may arbitrarily revoke their credentials or even ID cards and passports.

\section{Overview}

\subsection{Applications}
\subsection{Key contributions}

\section{Implementation}

In this section we will provide a detailed description of the
algorithm we propose for Selective Disclosure using BLS signatures
(SD-BLS).

We use both the classical mathematical notation and a reference code
implementation that is a dialect of Lua syntax and works efficiently
in the Zenroom VM. Being a self-contained application written in C,
Zenroom can be built for several CPU architectures and operative
systems, both as command line interface (CLI) application and as a
library. The Zenroom VM executes a Lua dialect allowing to follow very
closely the mathematical formulation of algorithms we show in this
article: it is free and open source software that is published and
documented on Zenroom.org

\subsection{Notations and assumptions}

We will adopt the following notations:
\begin{itemize}

\item $\mathbb{F}_p$ is the prime finite field with $p$ elements
  (i.e. of prime order $p$);

\item $E$ denotes the (additive) group of points of the curve
  BLS381-12 \cite{bls381-12} which can be described with the
  Weierstrass form $y^2=x^3 + 16$;

\item $E_T$ represents instead the group of points of the twisted
  curve of BLS381-12, with embedding degree $k=12$. The order of
  this group is the same of that of $E$;

\end{itemize}

We also require defining the notion of a cryptographic
pairing. Basically it is a function $e:
\mathbb{G}_1\times\mathbb{G}_2\to \mathbb{G}_T$, where
$\mathbb{G}_1,\mathbb{G}_2$ and $\mathbb{G}_T$ are all groups of same
order $n$, such that satisfies the following properties:

\begin{itemize}

\item [i.] \emph{Bilinearity}, i.e. given $P_1,Q_1\in\mathbb{G}_1$
  and $P_2,Q_2\in\mathbb{G}_2$, we have
  \begin{align*}
    e(P_1+Q_1,P_2) = e(P_1,P_2)\cdot e(Q_1,P_2) \\
    e(P_1,P_2+Q_2) = e(P_1,P_2)\cdot e(P_1,Q_2)
  \end{align*}

\item[ii.] \emph{Non-degeneracy}, meaning that for all
  $g_1\in\mathbb{G}_1, g_2\in\mathbb{G}_2$, $e(g_1,g_2)\ne
  1_{\mathbb{G}_T}$, the identity element of the group
  $\mathbb{G}_T$;

\item[iii.] \emph{ Efficiency}, so that the map $e$ is easy to
  compute;

\item[iv. ] $\mathbb{G}_1\ne \mathbb{G}_2$, and moreover, that
  there exist no efficient homomorphism between $\mathbb{G}_1$ and
  $\mathbb{G}_2$.

\end{itemize}

For the purpose of our protocol we will have $\mathbb{G}_1 = E_T$ and
$\mathbb{G}_2 = E$, and $\mathbb{G}_T\subset \mathbb{F}_{p^{12}}$ is
the subgroup containing the $n$-th roots of unity, where $n$ is the
order of the groups $E$ and $E_T$. Instead $e: E_T \times E\to
\mathbb{G}_T$ is the \emph{Miller pairing}, which in our work is
encoded as the method \verb!miller(ECP2 P, ECP Q)!. \\

The following code implements this setup in Zenroom:
\begin{lstlisting}[style=lua,caption={Setup}]
  G1 = ECP.generator()
  G2 = ECP2.generator()
  HG1 = ECP.hashtopoint
  Miller = PAIR.ate
\end{lstlisting}


\subsection{Issuance} \label{issuance}

As for other well known algorithms BLS signing will work following
three main steps:
\begin{itemize}

\item \textbf{Key Generation phase.} For an issuer who wants to sign
  a credential $m$, a secret key $sk$ is randomically chosen
  uniformly in $\mathbb{F}_n$, where $n$ is the order of the
  groups $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$. The
  corresponding public key $pk$ is the element $sk\cdot G_2\in
  E_T$;

\item \textbf{Signing phase.} The credential $m$ is first hashed into
  the point $U\in E$, which in our scheme is done by the method
  \verb!hashtopoint!; the related signature is then given by $\sigma =
  sk\cdot U$;

\item \textbf{Verification phase.} For an other user that wants to
  verify the authenticity and the integrity of the message $m$, it
  needs to

  \begin{itemize}

  \item [1.] parse $m, pk$ and $\sigma$

  \item [2.] hash the message $m$ into the point $U$ and then
    check if the following identity holds,

    \[
    e(pk,U) = e(G_2,\sigma)
    \]

  \end{itemize}

\end{itemize}

If verification passes it means that $\sigma$ is a valid signature for
$m$.

 In Zenroom this is simply done like this:

\begin{lstlisting}[style=lua,caption={Issuer key generation}]
function keygen()
   local sk = INT.random()
   return { sk = sk,
			pk = G2 * sk }
end
\end{lstlisting}

\begin{lstlisting}[style=lua,caption={Issuer signature}]
function sign(sk, msg)
   return HG1(msg) * sk
end
\end{lstlisting}

BLS signatures also support aggregation: it is possible to aggregate a
collection of multiple signatures $\sigma_i$ (each one related to a
different message $m_i$) into a singular new object $\sigma$, that can
be validated using the respective public keys $pk_i$ in a suitable
way.

Since $\sigma_i\in G_1 \forall i$, the algorithm has an homomorphic
property. We exploit this property to add a revocation signature into
the signed credential.

Let's use simple key equal value strings as credentials, i.e:

\begin{lstlisting}[style=lua,caption={Holder requests signature of claims}]
CLAIMS = {
  name = 'Pasqualino',
  surname = 'Frafuso',
  nickname = 'Settebellezze',
  born_in = 'Napoli',
  gender = 'male',
  above_18 = 'true',
  nationality = 'italian'
}
\end{lstlisting}

The issuer can send them back signed using this Zenroom code:

\begin{lstlisting}[style=lua,caption={Issuer signs claims}]
SIGNED_CLAIMS = { }
REVOCATIONS = { }
for k,v in pairs(CLAIMS) do
-- create the revocation key
   local rev = BIG.random()
   local id = k..'='..v
   local sig = sign(A.sk, id)
-- add the revocation signature
   + sign(rev, id)
-- send signed claims to holder
   SIGNED_CLAIMS[id] = {
     sig,      -- pos 1
     G1 * rev, -- pos 2
     G2 * rev, -- pos 3
   }
-- save revocation in issuer DB
   REVOCATIONS['HolderID/'..id] = rev
end
\end{lstlisting}

At the end of this phase the holder is sent the SIGNED-CLAIMS
to be stored in a private wallet, and the issuer stores
REVOCATIONS into a private database that can be used later to
issue revocations.

The revocations database is privacy sensitive and the issuance of
revocations is also sensitive to corruption, and we will detail
mitigations about this later.

\subsection{Presentation} \label{presentation}

As we have done in the issuance phase (\ref{issuance}), we exploit the
homomorphic property of BLS signatures once again, but this time to
render the presented signature unlinkable (impossible to trace across
multiple presentations) by adding a "blinding factor" signature to the
one provided by the issuer. \\

%% TODO: math formula della presentazione
Let $\mathcal{H}$ denote a cryptographic hash function (say SHA-256) and let $\varepsilon$ be an integer chosen uniformly at random that serve as the blinding factor.
Using the same technique of the Tripartite Diffie-Hellman Key Exchange (insert reference) we construct a secret that is binded to the blinding factor, the Issuer public key and the "revocation point" $r_1 = rev \cdot G_1$ computed in the issuance phase:

\begin{equation}\label{tau_f}
    \tau = \mathcal{H}(e(A.pk, r_1)^{\varepsilon})
\end{equation}

When the Holder need to disclose a particular claim $m$ we construct the credential proof as follow:
let $\sigma$ be the signature of the claim provided by the Issuer, then apply the blinding factor to the signature using the secret $\tau$
\begin{equation}\label{claim.s}
    s = \sigma + sign(\tau, m)
\end{equation}
and the corresponding public key computed as
\begin{equation*}
    p = r_2 + G_2 \cdot \tau
\end{equation*}
where $r_2$ is the revocation key linked to the claim.
We also attach the public key $r = G_1 \cdot \varepsilon$ that correspond to the secret key $\varepsilon$.

Qui link al codice relativo.

Presented claims can be encoded in JSON and url64 for a credential proof that will look like this:

\begin{lstlisting}[language=json,caption={Credential proof}]
{
  "credential_proof": [
    {
      "id": "gender=male",
      "p": "lrrMVQ2PYWm..." (128b),
      "r": "AhKWxDssQzm..." (68b),
      "s": "Ag15xYNw-mo..." (68b)
    },
    {
      "id": "name=Pasqualino",
      "p": "oirzmOKDdFt...", (128b)
      "r": "Aw-uvlOmOEU...", (68b)
      "s": "AxjFGZIT6bb..."  (68b)
    },
    {
      "id": "above_18=true",
      "p": "lv25dTFG91t...", (128b)
      "r": "AhBfXz8mBis...", (68b)
      "s": "Aw6EVThZcf5..."  (68b)
    }
  ],
  "verifier": "did:dyne:IssuerID"
}
\end{lstlisting}

\subsection{Verification}

Credential verification is made by checking that the issuer has signed the blinded proof being presented. In order to do that the credential issuer's public key must be added to the proof.\\
As explained in section \ref{presentation} we can consider the credential proof as a collection of tables of the following form:
\begin{equation*}
    c_p = \{id, p, r, s \}
\end{equation*}
where $s$ and $p$ are resp. the sig and the pk of the credential proof of the string $id$
after verifing the status of the revocation, we can check the validity of the presented claim computing the key
\begin{equation*}
    pk = A.pk + p
\end{equation*}
and verify the bls signature.

\subsubsection{Proof of correctness}
(questa è praticamente una proof dell'homomorphic property...)
The signature $s$ is given by
\begin{equation*}
\begin{split}
    s &= \sigma + sign(\tau, id) \quad \text{where} \\
    \sigma &= sign(A.sk, id) + sign(rev, id) \\
    \text{so} \quad s &= A.sk U + rev U + \tau U  
\end{split}
\end{equation*}
where $U$ is the mapping of the string $id$ in the group $G_1$.\\
Recalling the verification formula, it holds that:
\begin{equation*}
\begin{split}
 e(pk, U) &= e(A.skG_2 + revG_2 + \tau G_2, U) \\
 &= e(A.skG_2 + revG_2)\cdot e(\tau G_2, U) \\
 &= e(A.skG_2, U) \cdot e(revG_2, U) \cdot e(\tau G_2, U) \\
 &= e(G_2, A.sk U) \cdot e(G_2, rev U) \cdot e(G_2, \tau U) \\
 &= e(G_2, A.sk U) \cdot e(G_2, rev U + \tau U) \\
 &= e(G_2, A.sk U + rev U + \tau U) \\
 &= e(G_2, s) \\
\end{split}    
\end{equation*}
where each equality holds for the bilinearity of the Miller loop.

\subsection{Revocation}

To make sure no revocation has been emitted for each credential, we update the revocation list from the issuer. A revocation list can be publicly distributed since revocation keys do not provide any information on the identity of holders, unless they are presented in a verification.

\begin{lstlisting}[language=json,caption={Revocation list}]
{
  "revocations": {
    "born_in=Napoli": "P7uJd0-..", (44B)
    "gender=male": "B9mNCjiMj..", (44B)
    "nationality=italian": "F.."  (44B)
  }
}
\end{lstlisting}

Given an element $c_p = \{id, p, r, s \}$ of the credential proof table and the Issuer public key $A.pk$, if the claim id is present in the revocation list we can take the corresponding revocation private key $rev$ and compute the factor $\tau$ as
\begin{equation}\label{tau}
        \tau = \mathcal{H}(e(A.pk, r)^{rev})
\end{equation}

The equation \eqref{tau} gives the same result as \eqref{tau_f} since using the bilinearity of the pairing we have (qui possiamo citare https://cgi.di.uoa.gr/~aggelos/crypto/page4/assets/joux-tripartite.pdf)
\begin{equation*}
    \begin{split}
        \tau &= \mathcal{H}(e(A.pk, r)^{rev}) \\
        &= \mathcal{H}(e(A.pk, G_1 \cdot \varepsilon)^{rev}) \\
        &= \mathcal{H}(e(A.pk, G_1)^{rev + \varepsilon}) \\
        &= \mathcal{H}(e(A.pk, G_1 \cdot rev)^{\varepsilon}) \\
        &= \mathcal{H}(e(A.pk, r_1)^{\varepsilon})
    \end{split}
\end{equation*}

Then we can verify if a credential claim has been revoked checking first if the revocation public key match:
\begin{equation*}
    G_2 \cdot rev = p - G_2 \cdot \tau
\end{equation*}
and then verify the following signature with issuer pk
\begin{equation}\label{sig_minus}
    sig = s - sign(\tau, id) - sign(rev, id) 
\end{equation}
This signature should be verified with issuer pk since:
\begin{equation*}
    \begin{split}
        s &= \sigma + sign(\tau, id) \quad \text{from \eqref{claim.s}} \\
        &=  sign(sk, id) + sign(rev, id) + sign(\tau, id)
    \end{split}
\end{equation*}
then exploiting the homomorphic property of BLS signature
we got that $sig$ in \eqref{sig_minus} is signed using the issuer private key.
Qui si può inserire reference all'implementazione del metodo.
 TODO(?): spiegare perchè non puoi fingere una revocation key?
 
\subsection{Security considerations}

BLS signatures and the proof system obtained with credentials are
considered secure by assuming the existence of random oracles
\cite{random-oracle}, together with the decisional Diffie-Hellman
Problem (DDH) \cite{DDH-problem}, the external Diffie-Hellman Problem
(XDH), and with the Lysyanskaya-Rivest-Sahai-Wol Problem (LRSW)
\cite{lrsw-assumption}, which are connected to the Discrete
Logarithm. In fact, under these assumptions, we have that our protocol
satisfies unforgeability, blindness, and unlinkability.

One may object about the maturity of pairing-based ellipcic curve
cryptography despite various efforts to measure its security and
design curve parameters that raise it, it is reasonable to consider
this as a pioneering field of cryptography in contrast to well tested
standards.

In addition to considerations on the maturity of EC, the future growth
of quantum-computing technologies may be able to overcome the Discrete
Logarithmic assumptions by qualitatively different computational
means. Reflow then may be vulnerable to quantum-computing attacks, as
well hard to patch, because the pairing-based design sits at its core
with the adoption of ATE / Miller loop pairing of curves in twisted
space, a practice that is not covered by research on quantum-proof
algorithms and will eventually need more time to be addressed; however
this is all speculative reasoning on what we can expect from the
future.

The SD-BLS implementation we are presenting in this paper is
demonstrated using the BLS381-12 curve \cite{bls381-12} also adopted
by ETH2.0. Debating the choice of BLS381-12 is beyond the scope of
this paper, but is worth mentioning that we can easily switch usingthe
BLS461 curve based on a 461 bit prime, hence upgrading our
implementation to 128 bit security \cite{updating-key-pairings}
against attacks looking for discrete logs on elliptic curves
\cite{discrete-log-attack}.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}