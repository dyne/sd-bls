\documentclass[conference]{IEEEtran}
% \IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
%% \usepackage{natbib}

\usepackage{listings}
\lstdefinestyle{lua}{
  language=[5.3]Lua,
  basicstyle=\ttfamily,
  keywordstyle=\color{magenta},
  stringstyle=\color{blue},
  commentstyle=\color{black!50}
}
% solarized
\lstset{
    % How/what to match
    sensitive=false,
    % Extra margin on line (align with paragraph)
    xleftmargin=\parindent,
    % Put extra space under caption
    belowcaptionskip=1\baselineskip,
    % Break long lines into multiple lines?
    breaklines=true,
    % Show a character for spaces?
    showstringspaces=false,
    tabsize=2
}

\definecolor{eclipseStrings}{RGB}{42,0.0,255}
\definecolor{eclipseKeywords}{RGB}{127,0,85}
\colorlet{numb}{magenta!60!black}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    commentstyle=\color{eclipseStrings}, % style of comment
    stringstyle=\color{eclipseKeywords}, % style of strings
%    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
%    breaklines=true,
%    frame=lines,
    string=[s]{"}{"},
    comment=[l]{:\ "},
    morecomment=[l]{:"},
    literate=
        *{0}{{{\color{numb}0}}}{1}
         {1}{{{\color{numb}1}}}{1}
         {2}{{{\color{numb}2}}}{1}
         {3}{{{\color{numb}3}}}{1}
         {4}{{{\color{numb}4}}}{1}
         {5}{{{\color{numb}5}}}{1}
         {6}{{{\color{numb}6}}}{1}
         {7}{{{\color{numb}7}}}{1}
         {8}{{{\color{numb}8}}}{1}
         {9}{{{\color{numb}9}}}{1}
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Privacy Preserving Selective Disclosure and Issuer Revocation of Verifiable Credentials\\
%% {\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and should not be used}
\thanks{Dyne.org Foundation}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Denis Roio}
\IEEEauthorblockA{
% \textit{dept. name of organization (of Aff.)} \\
\textit{Dyne.org Foundation}\\
Amsterdam, The Netherlands \\
jaromil@dyne.org}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Andrea D'Intino}
\IEEEauthorblockA{
% \textit{dept. name of organization (of Aff.)} \\
\textit{The Forkbomb Company}\\
Copenhagen, Denmark \\
andrea@forkbomb.eu}
}

\maketitle

\begin{abstract}

It is of critical importance to design digital identity systems that
ensure the privacy of citizens as well protect them from state
corruption as the identity issuer. Unfortunately, what Europe and USA
state organizations are currently developing does not offer such basic
protections. As a solution we introduce a method for untraceable
selective disclosure and privacy preserving revocation of digital
credentials, utilizing the unique homomorphic characteristics of
second order Elliptic Curves and Boneh-Lynn-Shacham (BLS) signatures
operated on them. Our approach ensures that users can selectively
reveal only the necessary attributes, while protecting their privacy
across multiple presentations and against colluding verifiers. Since
we also want to protect users from issuer corruption, we apply a
threshold for credential issuance and revocation to mandate a
collective agreement among multiple issuers. Finally, our method of
revocation does not give out any information on the identity of
holders of revoked credentials.

\end{abstract}

\begin{IEEEkeywords}
Privacy, Selective disclosure, BLS signatures, Digital credentials
\end{IEEEkeywords}

\section{Introduction}
Digital identity systems implement credential issuance and presentation mechanisms so that a person can voluntarily disclose his or her own acquired skills, professed attributes, or completed accomplishments. Credentials are signed by issuer authorities and encapsulated within various forms of digital proofs to be held in digital wallets, empowering individuals to reveal only chosen details to designated recipients, to limit data exposure and permit a user-controlled release of information.

Such systems are known as selective disclosure and this article aims at improving their cryptographic implementation to adhere to basic privacy-by-design standards.

\subsection{State of the art}

Selective disclosures are being used by nation states across the world in their next generation identity systems, for instance EIDAS2.0 in Europe where the European Digital Identity Wallet Architecture and Reference Framework mandates the use of the SD-JWT standard. Unfortunately the only SD-JWT implementation known and found in identity wallet implementations today adopts simple HMAC based cryptography to generate proofs.

In North America the situation seems to be different: the cryptography adopted is based on the BBS+ algorithm and applied to W3C Verifiable Credentials to obtain an higher degree of privacy.

The different choice of syntax in these two approaches is negligible, being Javascript Web Tokens of W3C Verifiable Credentials doesn't changes much from our point of view. But the cryptographic algorithms adopted have great importance for our purpose and they lack the features necessary to face three important threats which render them unsuitable to be used in real world situations.

\subsection{Threats considered}

\paragraph{Linkability}

Every presentation of an HMAC proof is identical and this makes it possible for colluding verifiers to trace an holder identity by following disclosures. In order to preserve the privacy of a credential holder the proofs disclosed by the wallet should not be traceable across different presentations. This threat appears to be well mitigated by BBS+ through its Zero Knowledge Proof implementation.

\paragraph{Lack of Revocation}

There is no revocation system designed, either for HMAC or BBS+. This may be mitigated by expiration dates, but in some cases they are not enough and interactive revocation is necessary. Since the choice is left open to developers, we will face huge privacy breaches with the adoption of revocation lists.

%% - https://github.com/ministero-salute/it-dgc-verificaC19-android/issues/103
%% - https://osf.io/preprints/lawarxiv/yc6xu


\paragraph{Issuer Corruption}

If the choice of interactive revocation is left to a single issuer, one may unilaterally choose to revoke credentials, without being subject to revision or having to seek consensus with a quorum of issuers. This situation leads to censorship and persecution of engaged individuals like journalists or activists living under dictatorial regimes that may arbitrarily revoke their credentials or even ID cards and passports.

\section{Overview}

\subsection{Applications}
\subsection{Key contributions}

\section{Implementation}

In this section we will provide a detailed description of the
algorithm we propose for Selective Disclosure using BLS signatures
(SD-BLS).

We use both the classical mathematical notation and a reference code
implementation that is a dialect of Lua syntax and works efficiently
in the Zenroom VM. Being a self-contained application written in C,
Zenroom can be built for several CPU architectures and operative
systems, both as command line interface (CLI) application and as a
library. The Zenroom VM executes a Lua dialect allowing to follow very
closely the mathematical formulation of algorithms we show in this
article: it is free and open source software that is published and
documented on Zenroom.org

\subsection{Notations and assumptions}

We will adopt the following notations:
\begin{itemize}

\item $\mathbb{F}_p$ is the prime finite field with $p$ elements
  (i.e. of prime order $p$);

\item $E$ denotes the (additive) group of points of the curve
  BLS381-12 \cite{bls381-12} which can be described with the
  Weierstrass form $y^2=x^3 + 16$;

\item $E_T$ represents instead the group of points of the twisted
  curve of BLS381-12, with embedding degree $k=12$. The order of
  this group is the same of that of $E$;

\end{itemize}

We also require defining the notion of a cryptographic
pairing. Basically it is a function $e:
\mathbb{G}_1\times\mathbb{G}_2\to \mathbb{G}_T$, where
$\mathbb{G}_1,\mathbb{G}_2$ and $\mathbb{G}_T$ are all groups of same
order $n$, such that satisfies the following properties:

\begin{itemize}

\item [i.] \emph{Bilinearity}, i.e. given $P_1,Q_1\in\mathbb{G}_1$
  and $P_2,Q_2\in\mathbb{G}_2$, we have
  \begin{align*}
    e(P_1+Q_1,P_2) = e(P_1,P_2)\cdot e(Q_1,P_2) \\
    e(P_1,P_2+Q_2) = e(P_1,P_2)\cdot e(P_1,Q_2)
  \end{align*}

\item[ii.] \emph{Non-degeneracy}, meaning that for all
  $g_1\in\mathbb{G}_1, g_2\in\mathbb{G}_2$, $e(g_1,g_2)\ne
  1_{\mathbb{G}_T}$, the identity element of the group
  $\mathbb{G}_T$;

\item[iii.] \emph{ Efficiency}, so that the map $e$ is easy to
  compute;

\item[iv. ] $\mathbb{G}_1\ne \mathbb{G}_2$, and moreover, that
  there exist no efficient homomorphism between $\mathbb{G}_1$ and
  $\mathbb{G}_2$.

\end{itemize}

For the purpose of our protocol we will have $\mathbb{G}_1 = E_T$ and
$\mathbb{G}_2 = E$, and $\mathbb{G}_T\subset \mathbb{F}_{p^{12}}$ is
the subgroup containing the $n$-th roots of unity, where $n$ is the
order of the groups $E$ and $E_T$. Instead $e: E_T \times E\to
\mathbb{G}_T$ is the \emph{Miller pairing}, which in our work is
encoded as the method \verb!miller(ECP2 P, ECP Q)!. \\

The following code implements this setup in Zenroom:
\begin{lstlisting}[style=lua,caption={Setup}]
  G1 = ECP.generator()
  G2 = ECP2.generator()
  HG1 = ECP.hashtopoint
  Miller = PAIR.ate
\end{lstlisting}


\subsection{Issuance} \label{issuance}

As for other well known algorithms BLS signing will work following
three main steps:
\begin{itemize}

\item \textbf{Key Generation phase.} For an issuer who wants to sign
  a credential $m$, a secret key $sk$ is randomically chosen
  uniformly in $\mathbb{F}_n$, where $n$ is the order of the
  groups $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$. The
  corresponding public key $pk$ is the element $sk\cdot G_2\in
  E_T$;

\item \textbf{Signing phase.} The credential $m$ is first hashed into
  the point $U\in E$, which in our scheme is done by the method
  \verb!hashtopoint!; the related signature is then given by $\sigma =
  sk\cdot U$;

\item \textbf{Verification phase.} For an other user that wants to
  verify the authenticity and the integrity of the message $m$, it
  needs to

  \begin{itemize}

  \item [1.] parse $m, pk$ and $\sigma$

  \item [2.] hash the message $m$ into the point $U$ and then
    check if the following identity holds,

    \[
    e(pk,U) = e(G_2,\sigma)
    \]

  \end{itemize}

\end{itemize}

If verification passes it means that $\sigma$ is a valid signature for
$m$.

 In Zenroom this is simply done like this:

\begin{lstlisting}[style=lua,caption={Issuer key generation}]
function keygen()
   local sk = INT.random()
   return { sk = sk,
			pk = G2 * sk }
end
\end{lstlisting}

\begin{lstlisting}[style=lua,caption={Issuer signature}]
function sign(sk, msg)
   return HG1(msg) * sk
end
\end{lstlisting}

BLS signatures also support aggregation: it is possible to aggregate a
collection of multiple signatures $\sigma_i$ (each one related to a
different message $m_i$) into a singular new object $\sigma$, that can
be validated using the respective public keys $pk_i$ in a suitable
way.

Since $\sigma_i\in G_1 \forall i$, the algorithm has an homomorphic
property. We exploit this property to add a revocation signature into
the signed credential.

Let's use simple key equal value strings as credentials, i.e:

\begin{lstlisting}[style=lua,caption={Holder requests signature of claims}]
CLAIMS = {
  name = 'Pasqualino',
  surname = 'Frafuso',
  nickname = 'Settebellezze',
  born_in = 'Napoli',
  gender = 'male',
  above_18 = 'true',
  nationality = 'italian'
}
\end{lstlisting}

The issuer can send them back signed using this Zenroom code:

\begin{lstlisting}[style=lua,caption={Issuer signs claims}]
SIGNED_CLAIMS = { }
REVOCATIONS = { }
for k,v in pairs(CLAIMS) do
-- create the revocation key
   local rev = BIG.random()
   local id = k..'='..v
   local sig = sign(A.sk, id)
-- add the revocation signature
   + sign(rev, id)
-- send signed claims to holder
   SIGNED_CLAIMS[id] = {
     sig,      -- pos 1
     G1 * rev, -- pos 2
     G2 * rev, -- pos 3
   }
-- save revocation in issuer DB
   REVOCATIONS['HolderID/'..id] = rev
end
\end{lstlisting}

At the end of this phase the holder is sent the SIGNED-CLAIMS
to be stored in a private wallet, and the issuer stores
REVOCATIONS into a private database that can be used later to
issue revocations.

The revocations database is privacy sensitive and the issuance of
revocations is also sensitive to corruption, and we will detail
mitigations about this later.

\subsection{Presentation}

As we have done in the issuance phase (\ref{issuance}), we exploit the
homomorphic property of BLS signatures once again, but this time to
render the presented signature unlinkable (impossible to trace across
multiple presentations) by adding a "blinding factor" signature to the
one provided by the issuer.

%% TODO: math formula della presentazione

\begin{lstlisting}[style=lua,caption={Holder presents credentials}]
-- select credentials to disclose
disclose={'name','gender','above_18'}
CREDENTIAL_PROOF = { }
sha256 = HASH.new('sha256')
for m,v in pairs(SIGNED_CLAIMS) do
  local sig   = v[1]
  local revG1 = v[2]
  local revG2 = v[3]
  local claim = strtok(m, '=')
-- generate a blinding factor
  local er = BIG.random()
-- bind it to the revocation key
  local tri = BIG.new(sha256:process(
  (PAIR.ate(A.pk, revG1) ^ er):octet()
  ))
  if array_contains(disclose, claim[1]) then
	table.insert(CREDENTIAL_PROOF, {
    id = m,
-- apply blinding to the signature
    s = sig + sign(tri, m),
-- apply blinding to the public key
    p = (revG2 + G2*tri):to_zcash(),
-- attach the revocation hook
    r = G1*er
  })
  end
end
\end{lstlisting}

Presented claims can be encoded in JSON and url64 for a credential proof that will look like this:

\begin{lstlisting}[language=json,caption={Credential proof}]
{
  "credential_proof": [
    {
      "id": "gender=male",
      "p": "lrrMVQ2PYWm..." (128b),
      "r": "AhKWxDssQzm..." (68b),
      "s": "Ag15xYNw-mo..." (68b)
    },
    {
      "id": "name=Pasqualino",
      "p": "oirzmOKDdFt...", (128b)
      "r": "Aw-uvlOmOEU...", (68b)
      "s": "AxjFGZIT6bb..."  (68b)
    },
    {
      "id": "above_18=true",
      "p": "lv25dTFG91t...", (128b)
      "r": "AhBfXz8mBis...", (68b)
      "s": "Aw6EVThZcf5..."  (68b)
    }
  ],
  "verifier": "did:dyne:IssuerID"
}
\end{lstlisting}


\subsection{Verification}

Credential verification is made by checking that the issuer has signed the blinded proof being presented. In order to do that the credential issuer's public key must be added to the proof.

\begin{lstlisting}[style=lua,caption={Holder presents credentials}]
for _,proof in pairs(CREDENTIAL_PROOF) do
   local sig = proof.s
   local pk = ECP2.from_zcash(proof.p)
-- verify the credential isn't revoked
   assert(not
   revocation_contains(revocations,
   proof), "Revoked: "..proof.id)
-- verify the credential is authentic
   assert(
   verify(pk + A.pk, proof.id, sig) )
end
\end{lstlisting}


\subsection{Revocation}

To make sure no revocation has been emitted for each credential, we update the revocation list from the issuer. A revocation list can be publicly distributed since revocation keys do not provide any information on the identity of holders, unless they are presented in a verification.

\begin{lstlisting}[language=json,caption={Revocation list}]
{
  "revocations": {
    "born_in=Napoli": "P7uJd0-..", (44B)
    "gender=male": "B9mNCjiMj..", (44B)
    "nationality=italian": "F.."  (44B)
  }
}
\end{lstlisting}

\begin{lstlisting}[style=lua,caption={Holder presents credentials}]
function revocation_contains
  (revocations, claim)
  local res = false -- result
  local rev = revocations[claim.id]
  if rev then
    local tri =
      BIG.new(
        sha256:process(
          (Miller(A.pk,claim.r)^rev)
          :octet()
      ))
    if -- addendum of claim.p == revG2
      ECP2.from_zcash(claim.p) - (G2*tri) == G2*rev
    and -- unblinded issuer signature
      verify(A.pk, claim.id,
             claim.s
             - sign(tri, claim.id)
             - sign(rev, claim.id))
    then
      res = true
    end
  end
  return res
end
\end{lstlisting}

\subsection{Security considerations}

BLS signatures and the proof system obtained with credentials are
considered secure by assuming the existence of random oracles
\cite{random-oracle}, together with the decisional Diffie-Hellman
Problem (DDH) \cite{DDH-problem}, the external Diffie-Hellman Problem
(XDH), and with the Lysyanskaya-Rivest-Sahai-Wol Problem (LRSW)
\cite{lrsw-assumption}, which are connected to the Discrete
Logarithm. In fact, under these assumptions, we have that our protocol
satisfies unforgeability, blindness, and unlinkability.

One may object about the maturity of pairing-based ellipcic curve
cryptography despite various efforts to measure its security and
design curve parameters that raise it, it is reasonable to consider
this as a pioneering field of cryptography in contrast to well tested
standards.

In addition to considerations on the maturity of EC, the future growth
of quantum-computing technologies may be able to overcome the Discrete
Logarithmic assumptions by qualitatively different computational
means. Reflow then may be vulnerable to quantum-computing attacks, as
well hard to patch, because the pairing-based design sits at its core
with the adoption of ATE / Miller loop pairing of curves in twisted
space, a practice that is not covered by research on quantum-proof
algorithms and will eventually need more time to be addressed; however
this is all speculative reasoning on what we can expect from the
future.

The SD-BLS implementation we are presenting in this paper is
demonstrated using the BLS381-12 curve \cite{bls381-12} also adopted
by ETH2.0. Debating the choice of BLS381-12 is beyond the scope of
this paper, but is worth mentioning that we can easily switch usingthe
BLS461 curve based on a 461 bit prime, hence upgrading our
implementation to 128 bit security \cite{updating-key-pairings}
against attacks looking for discrete logs on elliptic curves
\cite{discrete-log-attack}.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
